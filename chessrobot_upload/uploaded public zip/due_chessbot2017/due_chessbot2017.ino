/***************************************************************************/
/*                 Definitions  & Declarations                             */
/***************************************************************************/

/*** INCLUDE ***/
#include "LedControl.h" //  need the library
#include <math.h>
#include <Servo.h>

/*** PINS ***/

#define pin_ARM_Base 3 //
#define pin_ARM_Wrist 4 // 
#define pin_ARM_Gripper 5 //
#define pin_LED_CLK 6 //
#define pin_LED_CS 7 // 
#define pin_LED_DIN 8 //
#define RELAYPIN 9

#define pin_ARM_Shoulder 12 //
#define pin_ARM_Elbow 13 //

#define pin_shift_PL 22// PL on shift register
#define pin_shift_CE 24 // CE on shift register
#define pin_shift_CP 26 // CP on shift register
#define pin_shift_Read 28 // output on shift register
#define serialScanDelay 0

// arm setup & calibration
Servo armServos[5];
int intDegMin[5] = {30, 54, 29, 62, 0};
int intDegMax[5] = {150, 143, 127, 180, 180};
//need to find MS values to hit those degrees (servo 1 reversed)
int intMSMin[5] = {805, 1890, 1890, 1000, 1000}; //1890
int intMSMax[5] = {2100, 1000, 875, 2155, 2000};
int intStepDelay = 700; //microseconds
int intServoPins[5] = {pin_ARM_Base, pin_ARM_Shoulder, pin_ARM_Elbow, pin_ARM_Wrist, pin_ARM_Gripper};
int intCurrentMS[5] = {0, 0, 0, 0, 0}; //gets written in setup based on fltCurrentDeg angles;
float fltSolvedDeg[5]; // stores last solved angles based on xyz provided to solveDeg
float fltCurrentDeg[5] = {90, 90, 38, 60, 90}; //safe initial angles but should be rewritten in setup
String strServoNames[5] = {"Base", "Shoulder", "Elbow", "Wrist", "Gripper"};
int intArmLengths[3] = {225, 234, 109}; // a , b, c. Stored in mm
int intArmOriginXYZ[3] = {200, 429, 78}; // position of shoulder relative to xyz origin
int intHomeXYZ[3] = {200, 310, 140}; //sitting position when waiting
int intSquareSide = 40; // mm
int intArmHoverHeight = 100;
int intCapturedPieceDumpXYZ[3] = {0, 100, intArmHoverHeight};
int intArmArcHeight = 20; // height above target spot that it will pass through on way to target square
int intArmGrabHeights[6] = {20, 30, 30, 25, 32, 45}; //pawn,knight,bishop,rook,queen,king
bool booCalibration = true;
bool booPrintServoLimits = false;
bool booDisableArm = false;

// shift register & LED
bool booDisableBoardChecking = false;
bool booBoardReadings[8][8]; // [0][0] is a1, [0][7] is a8, [7][0] is h1, [7][7] is h8
LedControl lc = LedControl(pin_LED_DIN, pin_LED_CLK, pin_LED_CS, 1); //arguments: MAX7219 pin 1 (DIN); CLK pin 13; LOAD pin 12 (CS); 1 as we are only using 1 MAX7219


//micromax
int M = 136, S = 128, I = 8e3, C = 799, Q, O, K, intNodeLimit;
double N; //changed to double in case size was problem
bool booMMPrint; // global variable to tell micromax to print debug
char L, *P;
signed char    w[] = {0, 1, 1, -1, 3, 3, 5, 9};
signed char          o[] = { -16, -15, -17, 0, 1, 16, 0, 1, 16, 15, 17, 0, 14, 18, 31, 33, 0,
                             7, -1, 6, 11, 8, 3, 6,
                             6, 4, 5, 7, 3, 5, 4, 6
                           };
char b[129],
     n[] = ".?+knbrq?*?KNBRQ",
           c[9]; //input buffer used by micromax

// Opening book variables (generated by excel)
char charOB[6][5] = { {"e2e4"}, {"d2d4"}, {"e7e5"}, {"c7c5"}, {"d7d5"}, {"g8f6"} }; //5 long for the null terminator needed by chess engine
int intOBMoveOptions[6] = {2, 0, 2, 0, 2, 0}; // for each spot in charOB, how many of the following moves are options from that spot
int intOBNext[6] = {2, 4, 0, 0, 0, 0}; // spot in array to move to if you select that move

/***************************************************************************/

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  randomSeed(analogRead(0));

  // make sure arm is attached, given starting angles, but powered down
  pinMode(RELAYPIN, OUTPUT);
  armPowerOff();
  for (int j = 0; j < 5; j++) {
    armServos[j].attach(intServoPins[j], intMSMin[j], intMSMax[j]);
    writeServoDeg(j, fltCurrentDeg[j]);
  }

  // prepare shift registers
  pinMode(pin_shift_CP, OUTPUT);
  pinMode(pin_shift_PL, OUTPUT);
  pinMode(pin_shift_CE, OUTPUT);
  pinMode(pin_shift_Read, INPUT);
  default_SR_Settings();

  // LED setup
  // the zero refers to the MAX7219 number, it is zero for 1 chip
  lc.shutdown(0, false); // turn off power saving, enables display
  lc.setIntensity(0, 1); // sets brightness (0~15 possible values)
  lc.clearDisplay(0);// clear screen

  Serial.println("setup() completed");
}

void loop() {
  int intAction = 0;
  int intDifficulty = 40000;
  String strCommand = "";
  bool booPlayForcedMoves = false;
  Serial.println("1 to play White, 2 to play Black, 3 CPU vs CPU, 4 HU vs HU, 5 to play stored moves, 6 to test arm, 7 to test board.\nda to disable arm. dc to disable board checking.");
  while (strCommand == "") {
    refreshBoard(false);
    delay(100);
    strCommand = checkForCommand(); //returns "" and wipes the serial stream if no carriage return was detected.
    //Serial.println(strCommand);
    //intAction = strCommand.toInt();  //returns 0 if can't find an int.
    if (millis() > 10000) {
      // start default game if no input
      if (!booDisableArm) armHandShake();
      playChess(0, intDifficulty, false);
    }
  }
  Serial.print(strCommand); Serial.println(" received.");

  if (strCommand == "6") armTester();
  if (strCommand == "7") boardTester();
  if (strCommand == "dc") {
    booDisableBoardChecking = true;
    Serial.println("Board checking disabled.");
  }
  if (strCommand == "da") {
    booDisableArm = true;
    Serial.println("Arm disabled.");
  }
  intAction = strCommand.toInt();
  if (intAction > 0 && intAction < 6) {
    if (intAction == 5)  {
      booPlayForcedMoves = true;
      intAction = 4;
    }
    if (!booDisableArm) armStartUp();
    playChess(intAction - 1, intDifficulty, booPlayForcedMoves); // 0 for robot black, 1 for robot white, 2 for robot both, 3 for human both (cpu will still move if given blank move) // changed limit from 5000
  }
  Serial.println("loop() completed");
}

// INPUT/OUTPUT functions

String checkForCommand() {
  String fulltext = "";
  char ch = 0;

  while (Serial.available() > 0)
  {
    ch = Serial.read();  //removes the read char from the serial stream
    if (ch == '\n' || ch == '\r') // line feed \n or carriage return \r
    {
      fulltext.concat('\0');
      return fulltext;
    }
    fulltext.concat(ch);
  }
  fulltext = "";
  return fulltext; // if there was no carriage return then treat as invalid string and return 0 (whole new command will need to be entered as serial buffer got wiped by reads)

}

